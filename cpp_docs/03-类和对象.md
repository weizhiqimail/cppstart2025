# 1. 创建一个类

## 1.1 创建一个基础类

```c++
class CRectangle {
public:
    int w, h;

    void Init(int w_, int h_) {
        w = w_;
        h = h_;
    }

    int Area() {
        return w * h;
    }

    int Perimeter() {
        return 2 * (w + h);
    }
};
```

## 1.2 栈上创建对象：`CRectangle rect1{};`

### 1.2.1 分析

+ **机制**： 
  + `rect1` 是栈上的自动变量，直接存储 `CRectangle` 对象实例。 
  + 内存由编译器在函数作用域内自动分配和释放。
+ **类型**：`rect1` 是 `CRectangle` 类型（非指针）。
+ **访问**：通过 . 运算符直接访问成员，如 `rect1.Init(10, 20)`。
+ **生命周期**：函数结束时自动销毁。


### 1.2.2 栈上创建对象
```c++
// 栈上创建对象：创建一个 CRectangle 对象
CRectangle rect1{};
rect1.Init(10, 20);
cout << "====== rect1 ======" << endl;
cout << "Area: " << rect1.Area() << endl;
cout << "Perimeter: " << rect1.Perimeter() << endl;

CRectangle *p1 = &rect1;
cout << "====== *p1 = &rect1 ======" << endl;
cout << "p1     = " << hex << p1 << endl;
cout << "&rect1 = " << hex << &rect1 << endl;
```

### 1.2.3 输出结果

```text
====== rect1 ======
Area: 200
Perimeter: 60

====== *p1 = &rect1 ======
p1     = 0x95b8fffa88
&rect1 = 0x95b8fffa88
```

## 1.3 堆上创建对象：`CRectangle *rect2 = new CRectangle();`

### 1.3.1 分析

+ **机制**：
  + `new CRectangle()` 在堆上分配内存，返回指向该内存的指针。 
  + `rect2` 是一个指针变量，存储的是堆内存的地址。
+ **类型**：`rect2` 是 `CRectangle*` 类型（指针）。
+ **访问**：通过 `->` 运算符访问成员，如 `rect2->Init(30, 40)`。
+ **生命周期**：需要手动调用 `delete rect2` 释放，否则会导致内存泄漏。

### 1.3.2 堆上创建对象

```c++
// 堆上创建对象：new 一个 CRectangle 对象
CRectangle *rect2 = new CRectangle();
rect2->Init(30, 40);
cout << "====== rect2 ======" << endl;
cout << dec;
cout << "Area: " << rect2->Area() << endl;
cout << "Perimeter: " << rect2->Perimeter() << endl;

CRectangle **p2 = &rect2;
cout << "====== p2 = rect2 ======" << endl;
cout << "p2     = " << hex << p2 << endl;
cout << "&rect2 = " << hex << &rect2 << endl;
```

### 1.3.3 输出结果

```text
====== rect2 ======
Area: 1200
Perimeter: 140
====== p2 = rect2 ======
p2     = 0xc6131ffe30
&rect2 = 0xc6131ffe30
```

### 1.3.4 为什么 `rect2` 必须是指针？

+ **内存位置**： 
  + 栈内存是临时的，对象生命周期与作用域绑定。 
  + 堆内存是持久的，适合需要动态控制生命周期的场景。
+ **`new` 的设计**：
  + `new` 返回指针是为了让程序员能够手动管理内存。 
  + 如果 `new` 直接返回对象（非指针），就无法区分栈和堆对象，也无法手动释放。
+ **指针的必要性**：
  + `rect2` 是一个指针变量，存储的是堆上对象的地址。 
  + 通过指针，可以在程序的任何地方访问和操作该对象，直到显式释放。
























