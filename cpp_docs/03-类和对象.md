# 1. 创建一个类

## 1.1 创建一个基础类

```c++
class CRectangle {
public:
    int w, h;

    void Init(int w_, int h_) {
        w = w_;
        h = h_;
    }

    int Area() {
        return w * h;
    }

    int Perimeter() {
        return 2 * (w + h);
    }
};
```

## 1.2 栈上创建对象：`CRectangle rect1{};`

### 1.2.1 分析

+ **机制**： 
  + `rect1` 是栈上的自动变量，直接存储 `CRectangle` 对象实例。 
  + 内存由编译器在函数作用域内自动分配和释放。
+ **类型**：`rect1` 是 `CRectangle` 类型（非指针）。
+ **访问**：通过 . 运算符直接访问成员，如 `rect1.Init(10, 20)`。
+ **生命周期**：函数结束时自动销毁。


### 1.2.2 栈上创建对象
```c++
// 栈上创建对象：创建一个 CRectangle 对象
CRectangle rect1{};
rect1.Init(10, 20);
cout << "====== rect1 ======" << endl;
cout << "Area: " << rect1.Area() << endl;
cout << "Perimeter: " << rect1.Perimeter() << endl;

CRectangle *p1 = &rect1;
cout << "====== *p1 = &rect1 ======" << endl;
cout << "p1     = " << hex << p1 << endl;
cout << "&rect1 = " << hex << &rect1 << endl;
```

### 1.2.3 输出结果

```text
====== rect1 ======
Area: 200
Perimeter: 60

====== *p1 = &rect1 ======
p1     = 0x95b8fffa88
&rect1 = 0x95b8fffa88
```

## 1.3 堆上创建对象：`CRectangle *rect2 = new CRectangle();`

### 1.3.1 分析

+ **机制**：
  + `new CRectangle()` 在堆上分配内存，返回指向该内存的指针。 
  + `rect2` 是一个指针变量，存储的是堆内存的地址。
+ **类型**：`rect2` 是 `CRectangle*` 类型（指针）。
+ **访问**：通过 `->` 运算符访问成员，如 `rect2->Init(30, 40)`。
+ **生命周期**：需要手动调用 `delete rect2` 释放，否则会导致内存泄漏。

### 1.3.2 堆上创建对象

```c++
// 堆上创建对象：new 一个 CRectangle 对象
CRectangle *rect2 = new CRectangle();
rect2->Init(30, 40);
cout << "====== rect2 ======" << endl;
cout << dec;
cout << "rect2 Area: " << rect2->Area() << endl;
cout << "rect2 Perimeter: " << rect2->Perimeter() << endl;

CRectangle *p2 = rect2;
p2->Init(50, 60);
cout << "p2 Area: " << p2->Area() << endl;
cout << "p2 Perimeter: " << p2->Perimeter() << endl;
cout << "====== p2 = rect2 ======" << endl;
cout << "p2     = " << hex << p2 << endl;
cout << "&rect2 = " << hex << &rect2 << endl;
```

### 1.3.3 输出结果

```text
====== rect2 ======
Area: 1200
Perimeter: 140
p2 Area: 3000
p2 Perimeter: 220
====== p2 = rect2 ======
p2     = 0x15762a41a60
&rect2 = 0x334a1ffa80
```

### 1.3.4 为什么 `rect2` 必须是指针？

+ **内存位置**： 
  + 栈内存是临时的，对象生命周期与作用域绑定。 
  + 堆内存是持久的，适合需要动态控制生命周期的场景。
+ **`new` 的设计**：
  + `new` 返回指针是为了让程序员能够手动管理内存。 
  + 如果 `new` 直接返回对象（非指针），就无法区分栈和堆对象，也无法手动释放。
+ **指针的必要性**：
  + `rect2` 是一个指针变量，存储的是堆上对象的地址。 
  + 通过指针，可以在程序的任何地方访问和操作该对象，直到显式释放。

# 2. 类和对象的使用

+ 使用头文件分拆代码，并引入代码。
+ 代码文件
  + Circle.h、Circle.cpp
  + Point.h、Point.cpp
  + Color.h、Color.cpp

+ 目录结构

```text
├── CircleModule/
│   ├── Circle.h
│   ├── Point.h
│   ├── Color.h
│   ├── Circle.cpp  （需要添加）
│   ├── Point.cpp  （需要添加）
│   └── Color.cpp  （需要添加）
├── main.cpp
└── cmake-build-debug/  （CLion 构建目录）
```

+ `main.cpp` 代码

```c++
#include <iostream>
#include "./CircleModule/Circle.h"

using namespace std;

int main() {
    // 初始化 Color 对象
    Color redColor = Color(255, 0, 0);
    Circle circle1 = Circle(10, 0, 0, redColor);
    circle1.calcArea();
    circle1.printInfo();

    Color greenColor = Color(0, 255, 0);
    Point point = Point(0, 0);
    Circle circle2 = Circle(20, point, greenColor);
    circle2.calcArea();
    circle2.printInfo();

    return 0;
}
```

+ `CMakeLists.txt` 补充代码。需要将 `CircleModule` 目录添加到 `CMakeLists.txt` 中。

```text
cmake_minimum_required(VERSION 3.30)
project(ccppstart2025)

set(CMAKE_CXX_STANDARD 20)

add_executable(ccppstart2025
        main.cpp
        CircleModule/Circle.cpp
        CircleModule/Color.cpp
        CircleModule/Point.cpp
)

include_directories(CircleModule)
```

# 3. 


















