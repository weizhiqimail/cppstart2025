# 2. C&C++ 位运算

## 2.1  位运算
+ 用于对整数类型(int, char, long等)变量中的某一位 (bit) 或者若干位进行操作。
+ 判断某一位是否为 1
+ 只改变其中的一位,而保持其他位都不变

## 5.2 `&` 按位与(双目)
+ 两个相同才为 1
+ 用途
  + 数据对齐（内存对齐），比如4字节对齐、16字节对齐
  + 屏蔽地位，保留高位。比如一个 32 位数字，前 24 位表示颜色通道，低 8 位表示透明度，忽略透明度，可以用 `& 0xffffff00` 来屏蔽掉低 8 位。
  + 操作系统分段地址、页表、缓存映射等，高 24 位是段号，低 8 位是页号，忽略页面，可以用 `& 0xffffff00` 来屏蔽掉低 8 位。
+ 总结：
  + 将低 N 位清零 = 快速向下取整到 **2ⁿ** 的整数倍 
  + 本质是**位对齐 / 屏蔽细节 / 提取上层信息**


## 5.3 `|` 按位或(双目)
+ 有一个是 1 就为 1
+ 用途: 将某变量的某些位置 1 且保留其他位不变
+ `n |= 0xff;`


## 5.4 `^` 按位异或(双目)
+ 两个数不同为 1，相同为 0
+ 用途: 将某变量中的某些位取反,且保留其他位不变
    + `n ^= 0xff;`
    + `a ^ b = c; c ^ b = a; a ^ c = b` (穷举法可证,可以实现最简单的加密和解密)
    + `int a = 5, b =7;`
    + 实现 a 和 b 的值交换
    + a = a ^ b;
    + b = b ^ a;
    + a = a ^ b;

```c++
int main(int argc, char *argv[]) {
    int a = 0b1100100;
    int f = 0xf;
    a = a ^ f;
    cout << "a: " << a << endl;
    return 0;
}
```

## 5.5 `~` 按位非(取反)(单目)
+ 0 变为 1，1 变为 0

## 5.6 `<<`左移(单目)
+ a << b
+ 将 a 各二进制全部左移 b 位即可
+ 左移 n 位,就等于是乘以 2 的 N 次方

## 5.7 `>>`右移(单目)
+ a >> b
+ 将 a 各二进制全部右移 b 位即可
+ 左移 n 位，就等于是除以 2 的 N 次方，除不尽的话，就往小里边取整
+ 如果原来的符号位为 1，右移时高位就补充为 1
+ 如果原来的符号位位 0，右移时高位就补充为 0

## 5.8 例题
+ 有两个 int 型的变量 a 和 n(0<=n<31)，要求写一个表达式，使得该表达式的值和a的第n位相同
+ (a>>n) & 1
+ (a & (1 << n)) >> n


















