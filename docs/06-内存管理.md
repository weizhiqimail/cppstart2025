# 1. 变量分类

+ **普通局部变量**：在函数或代码块内部定义，作用域和生命周期仅限于定义的区域。
+ **static 局部变量**：在函数或代码块内部定义，但具有静态存储期，生命周期贯穿整个程序运行。

+ **普通全局变量**：定义在函数外部，作用域为整个程序（多个文件可通过声明访问）。
+ **static 全局变量**：定义在函数外部，作用域仅限于当前文件。

+ **普通函数**：默认具有全局作用域，可被其他文件通过声明调用。
+ **static 函数**：作用域限于当前文件，其他文件无法访问。

## 1.1 普通局部变量

+ **定义**：在代码块（由`{}`包裹）内定义的变量。
+ **内存分配**：仅当程序执行到定义语句时，系统才在栈上分配内存。
+ **内存释放**：离开定义时的`{}`作用域后，内存自动释放。
+ **作用域**：仅在定义的`{}`内有效，离开后无法访问。
+ **初始化**：若未显式初始化，值是未定义的（随机值，取决于栈上内存的残留数据）。

```c++
#include <stdio.h>

void func() {
    int a; // 未初始化，值随机
    printf("a = %d\n", a);
}

int main() {
    func(); // 输出随机值
    return 0;
}
```

## 1.2 static 局部变量

+ **定义**：在代码块内用 `static` 关键字修饰的变量。
+ **内存分配**：在程序编译阶段就已经分配内存（位于数据段或BSS段），而不是在函数调用时。
+ **内存释放**：不会因离开作用域而释放，仅在程序结束时释放。
+ **作用域**：仍然局限于定义的`{}`内，外部不可访问。
+ **初始化**：
    + 若未初始化，默认值为0。
    + 初始化只在第一次执行时生效，后续调用不会重新初始化。
    + 只能用常量初始化，不能用变量（因为初始化在编译时完成）。

```c++
#include <stdio.h>

void staticFunc() {
    static int i = 0; // 只初始化一次
    i++;
    printf("static i = %d\n", i);
}

int main() {
    staticFunc(); // 输出: 1
    staticFunc(); // 输出: 2
    staticFunc(); // 输出: 3
    return 0;
}
```

## 1.3 普通全局变量

+ **定义**：在函数外部定义，未加 `static` 的变量。
+ **作用域**：整个程序（跨文件可通过 `extern` 声明访问）。
+ **声明与定义**：
    + 定义时分配内存（如 `int a = 100;`）。
    + 声明仅告知编译器变量存在（如 `extern int a;`），不分配内存。
+ **初始化**：
    + 未初始化时，默认值为0（位于 BSS 段）。
    + 初始化后存储在数据段。
+ **注意**：
    + 多次定义全局变量会导致链接错误，除非仅声明（加 `extern` ）。
    + 定义并赋值后，不能再次声明，只能赋值。

```c++
#include <stdio.h>

int a = 100; // 定义并初始化
extern int a; // 声明（仅在多文件场景有用）

int main() {
    printf("a = %d\n", a); // 输出: 100
    return 0;
}
```

## 1.4 static 全局变量

+ 定义：在函数外部用 `static` 修饰的变量。
+ 作用域：仅限于当前文件（文件作用域）。
+ 特点：
    + 不能用 `extern` 跨文件访问。
    + 不同文件中定义的同名 `static` 全局变量是独立的。
+ 初始化：未初始化时默认值为0。

```c++
#include <stdio.h>

static int a = 200; // 仅本文件可见

void printA() {
    printf("static a = %d\n", a);
}

int main() {
    printA(); // 输出: 200
    return 0;
}
```

## 1.5 变量总结

| 类型          | 作用域     | 生命周期     |
|-------------|---------|----------|
| auto 变量     | 一对 {} 内 | 当前函数     |
| static 局部变量 | 一对 {} 内 | 整个程序运行期间 |
| extern 变量   | 整个程序    | 整个程序运行期间 |
| static 全局变量 | 当前文件    | 整个程序运行期间 |
| extern 函数   | 整个程序    | 整个程序运行期间 |
| static 函数   | 当前文件    | 整个程序运行期间 |
| register 变量 | 一对 {} 内 | 当前函数     |

# 2. 二级指针和字符指针

+ 在C中，以下三种函数参数写法在传递数组时是等价的：

```c++
void fun1(char **p);       // 二级指针
void fun2(char *p[]);      // 指针数组
void fun3(char *p[100]);   // 指定大小的指针数组
```

+ `char **p` 表示指向字符指针的指针，常用于二维字符数组或动态分配的字符串数组。
+ `char *p[]` 和 `char *p[100]` 在函数参数中会被编译器视为 `char **p`，因为数组名在传递时退化为指针。
+ 注意：虽然写法上看起来是数组，实际操作时是按指针处理。

```c++
#include <stdio.h>

void printStrings(char **p, int n) {
    for (int i = 0; i < n; i++) {
        printf("%s\n", p[i]);
    }
}

int main() {
    char *strings[] = {"Hello", "World", "Grok"};
    printStrings(strings, 3);
    return 0;
}
```

# 3. 内存分区

## 3.1 C程序的内存分为以下区域：

+ **text（代码段）**：存储程序代码，只读。
+ **data（数据段）**：**存储初始化后的全局变量** 和 `static` 变量。
+ **bss（未初始化数据段）**：存储 **未初始化的全局变量** 和 `static` 变量，默认值为0。
+ **stack（栈区）**：存储普通局部变量，自动分配和释放，遵循先进后出。
+ **heap（堆区）**：动态分配内存，由程序员手动管理，遵循先进先出。

## 3.2 size命令

+ 在命令行执行 `size a.out` 可以查看各个段的大小。

```text
   text    data     bss     dec     hex filename
   1024     256      512    1792     700 a.out
```

+ text：程序代码段的大小为 1024 字节。
+ data：已初始化数据段的大小为 256 字节。
+ bss：未初始化数据段的大小为 512 字节。
+ dec：总内存消耗为 1792 字节（包括 text、data 和 bss）。
+ hex：总内存消耗的十六进制表示为 700。
+ filename：可执行文件名，a.out。

## 3.3 测试内存分区 - 空白代码

+ **size结果**：`text: 1127, data: 540, bss: 4`。
+ **分析**：包含基本代码和库函数的开销。

```c++
#include <stdio.h>
int main() { return 0; }
```

## 3.4 测试内存分区 - 未赋值的局部变量

+ **size结果**：不变。
+ **原因**：局部变量存储在栈上，不影响静态内存分区。

```c++
#include <stdio.h>
int main() { int a; return 0; }
```

## 3.5 测试内存分区 - 赋值的局部变量

+ size结果：不变。
+ 原因：栈上分配，不影响data或bss。

```c++
#include <stdio.h>
int main() { int a = 100; return 0; }
```

## 3.6 测试内存分区 - 未赋值的全局变量

+ **size结果**：bss 增加 4 字节。
+ **原因**：未初始化全局变量存储在bss段。

```c++
#include <stdio.h>
int a;
int main() { return 0; }
```

## 3.7 测试内存分区 - 赋值的全局变量

+ **size结果**：data 增加 4 字节，bss 减少 4 字节。
+ **原因**：初始化后移至data段。

```c++
#include <stdio.h>
int a = 100;
int main() { return 0; }
```

# 4. 指针指向堆栈空间

## 4.1 指针指向栈空间

+ 野指针问题：

```c++
int *p; // 未初始化，指向随机地址
*p = 10; // 操作非法内存，可能崩溃
```

+ 修正：

```c++
#include <stdio.h>
int main() {
    int a = 100;
    int *p = &a; // 指向合法栈空间
    *p = 10;
    printf("%d\n", *p); // 输出: 10
    return 0;
}
```

## 4.2 指针指向堆空间：申请内存：malloc 或 calloc，释放内存 free

+ C语言通过动态内存分配函数（如malloc、calloc）在堆区分配内存，并用free释放。
+ 
+ 动态分配的空间，如果程序没有结束，不会自动释放
+ 内存管理注意事项：
    + 未释放的内存会导致内存泄漏。
    + 访问已释放内存会导致未定义行为。

### 4.2.0 为什么要使用申请动态内存

+ 动态内存分配指的是在程序运行时，根据需要从堆（heap）中分配内存，而不是在编译时确定。
+ 使用场景：
  + **数组大小在编译时无法确定**（例如用户输入决定数组大小）。 
  + **对象的生命周期需要由程序控制**（例如 C++ 中使用 new 创建对象）。 
  + **需要动态调整内存大小**（例如使用 realloc() 来扩展数组）。 
  + **处理大数据结构**（如链表、树、图等，需要动态内存分配）。 
  + **内存管理需要手动控制**（内存的分配和释放由程序员控制）。
+ 使用动态内存分配可以有效管理内存，但也需要小心内存泄漏和野指针等问题。在使用动态内存时，确保每次分配的内存都能在合适的时机释放。

### 4.2.1 malloc 函数：申请内存

+ **原型**：`void *malloc(size_t size);`
+ **功能**：分配 `size` 字节的连续内存，返回首地址。
+ 返回值：
    + 成功：指向分配内存的 `void*` 指针。
    + 失败：`NULL`。
+ **特点**：
    + 返回的内存未初始化（内容随机）。
    + ANSI C后返回 `void*`，需强制转换为目标类型。

```c++
#include <stdio.h>
#include <stdlib.h>
int main() {
    double *ptd = (double *)malloc(30 * sizeof(double));
    if (ptd == NULL) {
        printf("分配失败\n");
        return 1;
    }
    ptd[0] = 3.14;
    printf("ptd[0] = %.2f\n", ptd[0]); // 输出: 3.14
    free(ptd); // 释放内存
    return 0;
}
```

### 4.2.2 calloc 函数：申请内存

+ **原型**：`void *calloc(size_t num, size_t size);`
+ **功能**：分配 `num` 个大小为 `size` 的存储单元，返回首地址。
+ **特点**：
    + 返回的内存初始化为0。
    + 返回类型同 `malloc（void*）`。
    + 参数：`num`（数量），`size`（单元素字节数），均为size_t类型。

```c++
#include <stdio.h>
#include <stdlib.h>
int main() {
    long *arr = (long *)calloc(100, sizeof(long));
    if (arr == NULL) {
        printf("分配失败\n");
        return 1;
    }
    printf("arr[0] = %ld\n", arr[0]); // 输出: 0
    free(arr);
    arr = NULL;
    return 0;
}
```

### 4.2.3 free 函数：释放内存

+ **原型**：`void free(void *ptr);`
+ **功能**：释放 `ptr` 指向的动态分配内存。
+ **注意**：
    + 仅释放 `malloc`、`calloc` 等分配的内存。
    + 释放后 `ptr` 变为野指针，建议置为 `NULL`。
    + 重复释放或释放 `NULL` 无害。
    + `free(p)` 释放的是 **p 指向的内存，而不是 p 变量**。p 是栈空间，但是 p 指向的地址是堆空间。
    + 同一块堆区内存只能释放一次
    + 释放不是内存消失，而是说这块内存用户不能再使用，系统已经回收，如果用户再使用，那么就是操作野指针，就是操作非法内存。

```c++
#include <stdio.h>
#include <stdlib.h>

int main() {

    int *p;
    p = (int *)malloc(sizeof(int));
    if (p == NULL) {
        printf("分配内存失败\n");
        return 0;
    }
    *p = 10;
    printf("%p\n", *p);
    free(p);
    // 不要这么使用，释放完毕之后就不要再使用
    // 编译器检测不到错误，但是并不意味着这样是正确的操作
    // 这样操作，以后代码是会有问题的。
    // 如果一定要使用，可以再申请
    *p = 10;
    printf("%p\n", *p);
    p = NULL; // 释放完毕之后，p 变量也要置为 NULL，避免野指针。
    return 0;
}
```

### 4.2.4 对比 malloc 和 calloc

+ `malloc` 速度快但不初始化。
+ `calloc` 初始化为0，适合需要清零的场景。

### 4.2.5 malloc, calloc 和 free 的使用

```c++
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *intArray;      // 用于 malloc 的整数数组指针
    float *floatArray;  // 用于 calloc 的浮点数数组指针
    int size = 5;       // 数组大小

    // 1. 使用 malloc 分配内存
    intArray = (int *)malloc(size * sizeof(int));
    if (intArray == NULL) {
        printf("malloc 分配内存失败！\n");
        return 1; // 退出程序
    }

    // 初始化 malloc 分配的内存（malloc 不自动清零）
    for (int i = 0; i < size; i++) {
        intArray[i] = i + 1; // 填充 1, 2, 3, 4, 5
    }

    // 输出 malloc 分配的数组内容
    printf("malloc 分配的整数数组：");
    for (int i = 0; i < size; i++) {
        printf("%d ", intArray[i]);
    }
    printf("\n");

    // 2. 使用 calloc 分配内存
    floatArray = (float *)calloc(size, sizeof(float));
    if (floatArray == NULL) {
        printf("calloc 分配内存失败！\n");
        free(intArray); // 释放之前分配的内存
        return 1;
    }

    // calloc 自动初始化为 0，修改部分元素
    floatArray[0] = 1.1;
    floatArray[1] = 2.2;
    floatArray[2] = 3.3;

    // 输出 calloc 分配的数组内容
    printf("calloc 分配的浮点数数组：");
    for (int i = 0; i < size; i++) {
        printf("%.1f ", floatArray[i]);
    }
    printf("\n");

    // 3. 释放内存并置空指针
    free(intArray);
    intArray = NULL; // 避免野指针
    printf("intArray 已释放，当前地址：%p\n", (void *)intArray);

    free(floatArray);
    floatArray = NULL;
    printf("floatArray 已释放，当前地址：%p\n", (void *)floatArray);

    return 0;
}
```

```text
输出的结果：

malloc 分配的整数数组：1 2 3 4 5
calloc 分配的浮点数数组：1.1 2.2 3.3 0.0 0.0
intArray 已释放，当前地址：(nil)
floatArray 已释放，当前地址：(nil)
```

## 4.3 内存泄漏与内存污染

+ **内存泄漏**：分配的堆内存未释放，程序结束前无法回收。
    + 示例：`int *p = malloc(sizeof(int));` 未调用 `free(p)`。
+ **内存污染**：访问或修改未分配/已释放的内存。
    + 示例：`free(p); *p = 20;` 操作野指针。

## 4.4 释放规范

+ 定义指针时初始化为 `NULL`。
+ 释放前检查是否为 `NULL`，释放后置为 `NULL`。

```c++
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *p = NULL;
    p = (int *)malloc(sizeof(int));
    if (p == NULL) {
        printf("分配失败\n");
        return 1;
    }
    *p = 10;
    if (p != NULL) {
        free(p);
        p = NULL; // 防止野指针
    }
    return 0;
}
```

## 4.5 堆区越界

+ 问题：`malloc(0)` 的行为未定义，可能返回 `NULL` 或最小分配单元。
+ 说明：malloc(0)可能成功但无法安全使用，需分配足够空间。

```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *p = NULL;
    p = (char *) malloc(0);
    // 按理来说，申请 0 大小的空间，实际上是什么内存空间都没有申请，所以实际上 p 还是空指针
    // 既然 p 是空指针，那么 p 就应该为 NULL
    // 但是实际结果是没有输出分配失败
    if (NULL == p) {
        printf("分配失败");
        return 0;
    }
    // 给 p 赋值，能够正常操作，也可以获取到赋值后的结果
    strcpy(p, "hello, world");
    printf("%s\n", p);
    free(p);
    return 0;
}
```

# 5. 存储类别

## 5.1 作用域分类

+ 块作用域 (Block Scope)：if for while 等语句块内定义的变量。
+ 函数作用域 (Function Scope)：函数内定义的变量。
+ 文件作用域 (File Scope)：变量定义在所有函数外部，对整个翻译单元可见。
+ 函数原型作用域 (Function Prototype Scope)：变量名仅在函数原型声明中有效。

```c++
// 函数原型作用域
#include <stdio.h>
void func(int x, double y); // x, y 仅在原型内有效
void func(int a, double b) { // a, b 与原型中的 x, y 无关
    printf("a = %d, b = %.1f\n", a, b);
}
int main() {
    func(1, 2.5); // 输出: a = 1, b = 2.5
    return 0;
}
```

+ 类作用域 (Class Scope) - 仅 C++：变量或函数在类定义范围内有效。
+ 命名空间作用域 (Namespace Scope) - 仅C++：变量或函数在命名空间内有效。

```c++
// 命名空间作用域
#include <iostream>
namespace MyNamespace {
    int value = 200; // 命名空间作用域
    void show() {
        std::cout << "value = " << value << std::endl; // 输出: 200
    }
}
int main() {
    MyNamespace::show();
    return 0;
}
```

| 作用域类型   | C 支持 | C++ 支持 | 示例说明      |
|---------|------|--------|-----------|
| 块作用域    | 是    | 是      | 局部变量，循环变量 |
| 函数作用域   | 是    | 是      | 函数参数      |
| 文件作用域   | 是    | 是      | 全局变量      |
| 函数原型作用域 | 是    | 是      | 函数原型参数名   |
| 类作用域    | 否    | 是      | 类成员变量/函数  |
| 命名空间作用域 | 否    | 是      | 命名空间内的标识符 |

+ 变量的定义在函数的外面，具有文件作用域(file scope)。

## 5.2 翻译单元和文件

C语言通过预处理器将 `#include` 指令替换为头文件内容，最终形成一个独立的“翻译单元”（Translation Unit）。

一个翻译单元包括一个源文件及其包含的所有头文件。具有文件作用域的变量实际上在整个翻译单元内可见。如果程序由多个源文件组成，则包含多个翻译单元。

每个翻译单元均对应一个源代码文件和它所包含的文件。

## 5.3 链接

链接（Linkage）描述了变量或函数在多个翻译单元之间的可见性。C语言定义了三种链接属性：

+ 无链接（No Linkage）：变量仅在定义的块、函数或原型内私有。例如，块 Ascending/descending block-local variables 和函数参数。
+ 内部链接（Internal Linkage）：变量具有文件作用域，但只能在定义它的翻译单元内访问。用 `static` 关键字修饰。
+ 外部链接（External Linkage）：变量具有文件作用域，可在多文件程序中通过声明访问。默认情况下，文件作用域变量具有外部链接。

## 5.4 存储期

存储期（Storage Duration）描述了变量所代表的对象在内存中的生存时间。C语言有以下四种存储期：

+ **静态存储期（Static Storage Duration）**：对象在程序整个执行期间存在。所有文件作用域变量（无论 `static` 与否）都具有静态存储期。
+ **自动存储期（Automatic Storage Duration）**：对象在进入定义它的块时分配内存，离开块时释放。块作用域的普通变量具有此存储期。
+ **线程存储期（Thread Storage Duration）**：用于并发编程，从声明时到线程结束存在。用 `_Thread_local`关键字声明，每个线程拥有独立副本。
+ **动态分配存储期（Allocated Storage Duration）**：通过 `malloc` 或 `calloc` 分配内存，手动管理，程序员负责释放（用 `free` ）。
+ 注意：对于文件作用域变量，`static` 关键字仅影响链接属性（内部链接），不改变其静态存储期。

## 5.5 五种存储类别

| 存储类别    | 存储期 | 作用域 | 链接 | 声明方式               |
|---------|-----|-----|----|--------------------|
| 自动      | 自动  | 块   | 无  | 块内                 |
| 寄存器     | 自动  | 块   | 无  | 块内，使用关键字 register  |
| 静态外部存储期 | 静态  | 文件  | 外部 | 所有函数外              |
| 静态内部链接  | 静态  | 文件  | 内部 | 所有函数外，使用关键字 static |
| 静态无链接   | 静态  | 块   | 无  | 块内，使用关键字 static    |

+ **自动变量**：默认存储类别，栈上分配，生命周期短暂。
+ **寄存器变量**：建议编译器将变量存储在CPU寄存器中以提高访问速度，但现代编译器通常自动优化，`register` 作用有限。
+ **静态变量**：无论作用域如何，其内存位置固定，值在函数调用间保留。

## 5.6 自动变量

+ **特性**：自动存储期、块作用域、无链接。
+ **声明**：块内定义的变量默认属于此类别，可用 `auto` 关键字显式声明（但不推荐，因与C++冲突）。
+ **访问**：仅在定义的块内通过变量名直接访问，或通过指针/参数间接传递。

```c++
#include <stdio.h>
void func() {
    int x = 10; // 自动变量
    printf("x = %d\n", x);
}
int main() {
    func(); // 输出: 10
    // printf("%d", x); // 错误：x 超出作用域
    return 0;
}
```

## 5.7 寄存器变量

+ **特性**：自动存储期、块作用域、无链接，建议存储在寄存器中。
+ **限制**：无法取地址（`&reg_var`非法）。
+ **声明**：用`register`关键字。

```c++
#include <stdio.h>
void func() {
    register int x = 5; // 建议存储在寄存器
    printf("x = %d\n", x);
    // int *p = &x; // 错误：寄存器变量无地址
}
```

## 5.8 块作用域的静态变量

+ **特性**：静态存储期、块作用域、无链接。
+ **特点**：内存位置固定，值在多次调用间保留。
+ **声明**：块内用`static`定义。

```c++
#include <stdio.h>
void count() {
    static int c = 0; // 仅初始化一次
    c++;
    printf("Count: %d\n", c);
}
int main() {
    count(); // 输出: 1
    count(); // 输出: 2
    return 0;
}
```

## 5.9 外部链接的静态变量

+ 特性：静态存储期、文件作用域、外部链接。
+ 声明：
    + 定义：函数外定义变量。
    + 声明：函数内用extern引用其他文件中定义的变量。
+ 使用：多文件程序中共享。

```c++
// file1.c
int global = 100; // 定义

// file2.c
#include <stdio.h>
extern int global; // 声明
int main() {
    printf("Global: %d\n", global); // 输出: 100
    return 0;
}
```

## 5.10 内部链接的静态变量

+ **特性**：静态存储期、文件作用域、内部链接。
+ **声明**：函数外用`static`定义，仅限当前翻译单元。
+ **特点**：不同文件中同名变量互不干扰。

```c++
#include <stdio.h>
static int x = 50; // 内部链接
void print_x() {
    printf("x = %d\n", x);
}
int main() {
    print_x(); // 输出: 50
    return 0;
}
```

