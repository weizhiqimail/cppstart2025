# 1. 词法陷阱

词法分析是编译器的第一步，将源代码分解为符号（token）。以下是常见的词法陷阱。

## 1.1 词法中的贪心法

+ **定义**：编译器从左到右扫描代码，尽可能将最长的字符序列识别为一个符号，直到无法组成合法符号为止。
+ **K&R表述**：在输入流中，下一个符号是从当前字符开始的最长可能符号。
+ 示例： 
  + 输入 `a+++b`： 
    + 贪心法识别为 `a`、`++`、`+`、`b`，而不是 `a`、`+`、`++`,`b`。 
    + 结果：`a++ + b`。
+ **扩展**：贪心法可能导致意外解析，需注意运算符边界。

```c++
#include <stdio.h>
int main() {
    int a = 5, b = 3;
    int c = a+++b; // a++ + b
    printf("a = %d, b = %d, c = %d\n", a, b, c); // 输出: a = 6, b = 3, c = 8
    return 0;
}
```

## 1.2 字符与字符串

+ **字符（单引号）**：
  + 表示整数，对应字符集中的值（如 ASCII 中 `a` = 97）。
+ **字符串（双引号）**：
  + 表示指向字符数组的指针，末尾自动添加 `\0`。
+ **扩展**：字符与字符串的混淆可能导致类型错误，需明确区分。

```c++
#include <stdio.h>
int main() {
    char c = 'a';
    char *s = "hello";
    printf("c as int: %d\n", c);       // 输出: 97
    printf("s as ptr: %p\n", (void*)s); // 输出: 字符串地址
    printf("s content: %s\n", s);       // 输出: hello
    return 0;
}
```

# 2. 语法陷阱

语法规则决定了代码的合法性，以下是常见的陷阱。

## 2.1 理解函数的声明

+ `float ff();`：`ff` 是返回 `float` 的函数。
+ `float *pf();`：`pf` 是返回 `float*` 的函数。
+ `float *g(), (*h)();`：
  + `*g()`：`g` 返回 `float*`。
  + `(*h)()`：`h` 是指向返回 `float` 的函数的指针。
+ `float (*)();`：类型转换符，表示指向返回 `float` 的函数指针。
+ **扩展**：函数指针的简化写法（如 `h()`）在 ANSI C 中合法，但 `*h()` 更明确。

```c++
#include <stdio.h>

float ff() { return 1.0; }
float *pf() { static float f = 2.0; return &f; }
float fval() { return 3.0; }
float (*h)() = fval; // 函数指针

int main() {
    printf("ff(): %.1f\n", ff());         // 输出: 1.0
    printf("*pf(): %.1f\n", *pf());       // 输出: 2.0
    printf("h(): %.1f\n", (*h)());        // 输出: 3.0
    printf("h() simplified: %.1f\n", h()); // 输出: 3.0 (ANSI C 简化)
    return 0;
}
```

## 2.2 运算符优先级问题

+ **优先级顺序**：单目 > 双目（算术） > 位移 > 关系 > 逻辑。
+ **关键点**：
  + 逻辑运算符低于关系运算符。
  + 位移运算符低于算术，高于关系。
+ **扩展**：使用括号明确优先级，避免歧义。

```c++
#include <stdio.h>
int main() {
    int a = 1, b = 2, c = 3;
    int r1 = a + b << 1;      // (a + b) << 1
    int r2 = a < b && b < c;  // (a < b) && (b < c)
    printf("r1 = %d\n", r1);  // 输出: 6
    printf("r2 = %d\n", r2);  // 输出: 1 (true)
    return 0;
}
```

# 3. 语义陷阱

语义涉及代码的含义，以下是常见的误区。

## 3.1 指针与数组

+ **等价性**：数组下标 `a[i]` 等价于指针运算 `*(a + i)`。
+ **指针加法**：`p + 1` 移动一个元素大小，而非字节。
+ **指针减法**：仅对同一数组内指针有效。
+ **扩展**：指针运算基于类型大小，需注意越界。

```c++
#include <stdio.h>
int main() {
    int arr[] = {10, 20, 30};
    int *p = arr;
    printf("arr[1] = %d\n", arr[1]);     // 输出: 20
    printf("*(p + 1) = %d\n", *(p + 1)); // 输出: 20
    printf("p + 1 addr: %p\n", (void*)(p + 1)); // 地址加 sizeof(int)
    return 0;
}
```

## 3.2 作为参数的数组声明

+ **转换**：数组参数自动转为指针。 
+ **等价性**：`char s[]` 等价于 `char *s`。
+ **扩展**：避免用数组语法误导非数组参数。

```c++
#include <stdio.h>
int strlen(char *s) {
    int len = 0;
    while (*s++) len++;
    return len;
}
int main() {
    char s[] = "hello";
    printf("Length: %d\n", strlen(s)); // 输出: 5
    return 0;
}
```

## 3.3 避免举隅法

+ 指针赋值：复制指针不复制数据。

```c++
#include <stdio.h>
int main() {
    int x = 5;
    int *p1 = &x;
    int *p2 = p1; // 复制指针
    *p2 = 10;
    printf("x = %d\n", x); // 输出: 10 (共享数据)
    return 0;
}
```

## 3.4 空指针并非空字符串

+ **空指针**：`NULL` 或 `0`，不可解引用。
+ **空字符串**：`""`，指向有效内存（含 `\0`）。
+ **扩展**：`NULL` 用于指针初始化，`""` 表示空字符串。

```c++
#include <stdio.h>
int main() {
    char *p = NULL;
    char *s = "";
    // printf("%s", *p); // 错误：解引用 NULL
    printf("Empty string: %s\n", s); // 输出: (空行)
    return 0;
}
```

# 4. 连接

连接器将目标模块整合为可执行文件。

## 4.1 连接器

+ **作用**：整合目标模块和库文件，生成可执行文件。
+ **外部对象**：函数和非 `static` 全局变量。
+ **命名冲突**： 
  + 同名外部对象在同一模块中非法。 
  + 跨模块同名对象由连接器解析。
+ **扩展**：`static` 通过名称修饰避免冲突。

```c++
// file1.c
int global = 5;
void print_global() { printf("%d\n", global); }

// file2.c
#include <stdio.h>
extern int global;
int main() { print_global(); return 0; } // 输出: 5
```

# 5. 库函数

标准库函数可能隐藏陷阱。

## 5.1 返回整数的 getchar 函数
+ 问题：char 类型可能无法容纳 EOF（通常为 -1）。
+ 修正：使用 int 接收返回值。

```c++
#include <stdio.h>
int main() {
    int c; // 改为 int
    while ((c = getchar()) != EOF) {
        putchar(c);
    }
    return 0;
}
```

## 5.2 缓冲输出与内存分配
+ **缓冲类型**： 
  + 无缓冲：立即输出。 
  + 行缓冲：遇换行输出。 
  + 全缓冲：缓冲满或 `fflush`。 
+ `setbuf`：设置输出缓冲区。
+ **扩展**：`BUFSIZ` 定义缓冲区大小，通常为 `512` 或 `1024` 字节。

```c++
#include <stdio.h>
int main() {
    char buf[BUFSIZ];
    setbuf(stdout, buf); // 设置缓冲区
    printf("Hello, ");
    fflush(stdout);      // 强制输出
    printf("world!\n");
    return 0;
}
```
