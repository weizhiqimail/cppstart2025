# 1. 字符串

+ C 语言没有字符串类型，用字符数组模拟。
+ 字符串一定是字符数组，字符数组不一定是字符串。
+ 如果字符数组以字符 `\0` 或数字 `0` 结尾，那么这个字符数组就是字符串。
+ `\0` 和 `0` 在二进制中都是 `00000000`（1 字节）。

```c++
#include <iostream>  // 输入输出流支持

using namespace std;

int main() {
    // 未显式添加空终止符的字符数组，可能导致未定义行为
    char a[] = {'m', 'a', 'r', 'k'};  // 缺少 '\0'，不是标准 C 字符串
    cout << "a (无空终止符): " << a << endl;  // 输出 "mark烫烫躩n犇" 后可能有垃圾字符

    cout << "----- 分隔符 -----\n";

    // 标准字符串，使用 '\0' 作为空终止符
    char b[] = {'m', 'a', 'r', 'k', '\0'};  // 显式添加空终止符
    cout << "b (显式 '\0'): " << b << endl;  // 输出 "mark"

    // 标准字符串，使用 0 作为空终止符（等价于 '\0'）
    char c[] = {'m', 'a', 'r', 'k', 0};  // 0 等价于 '\0'
    cout << "c (显式 0): " << c << endl;  // 输出 "mark"

    cout << "----- 分隔符 -----\n";

    // 定长数组，初始化部分元素，未初始化部分自动填充 0（包括空终止符）
    char d[10] = {'m', 'a', 'r', 'k'};  // 前 4 个字符为 "mark"，后 6 个为 0
    cout << "d (定长 10，部分初始化): " << d << endl;  // 输出 "mark"

    // 常用字符串初始化，自动在末尾添加空终止符 '\0'
    char e[10] = "mark";  // "mark" + '\0'，剩余填充 0
    cout << "e[4] (空终止符 ASCII 值): " << (int)e[4] << endl;  // 输出 0（'\0' 的值）

    cout << "----- 分隔符 -----\n";

    // 简洁字符串初始化，自动计算大小并添加 '\0'
    char f[] = "mark";  // 等价于 {'m', 'a', 'r', 'k', '\0'}
    cout << "f[4] (空终止符 ASCII 值): " << (int)f[4] << endl;  // 输出 0
    cout << "sizeof(f): " << sizeof(f) << endl;  // 输出 5（4 个字符 + '\0'）

    // 以 '\0' 开头的字符串，输出为空
    char g[] = "\0mark";  // '\0' 在开头，后续字符被忽略
    cout << "g (以 '\\0' 开头): \"" << g << "\"" << endl;  // 输出空字符串 ""

    cout << "----- 分隔符 -----\n";

    // 包含转义字符的字符串，'\012' 是八进制转义，表示换行符 '\n'
    char h[] = "\012mark";  // 等价于 {'\n', 'm', 'a', 'r', 'k', '\0'}
    cout << "h (含转义 '\\012' 为换行): \"" << h << "\"" << endl;  // 输出换行后 "mark"

    return 0;
}

/*
a (无空终止符): mark烫烫躩n犇  // 未定义行为，可能有垃圾字符
----- 分隔符 -----
b (显式 '\0'): mark
c (显式 0): mark
----- 分隔符 -----
d (定长 10，部分初始化): mark
e[4] (空终止符 ASCII 值): 0
----- 分隔符 -----
f[4] (空终止符 ASCII 值): 0
sizeof(f): 5
g (以 '\0' 开头): ""
----- 分隔符 -----
h (含转义 '\012' 为换行): "
mark"
 */
```

# 2. 字符串处理函数

## 2.1 `scanf`：用于从标准输入中读取格式化数据，如字符串、整数、浮点数等。

+ 函数签名 `int scanf(const char *format, ...);`
+ 常用格式符：
    + %s：读取字符串，遇空格/换行/Tab 停止
    + %d：读取整数
    + %c：读取字符
    + %f：读取 float
+ 注意事项
    + %s 读取时不包含空格，空格视为结束。
    + 输入会保留在标准输入缓冲区中，下一次读取可能读取剩下的内容。
    + 不做数组越界检查，容易产生缓冲区溢出。
    + 更安全的替代函数是 `fgets()`。

```c++
#include <stdio.h>

int main() {
    char buf[100] = {0};  // 用于存储用户输入的第一个单词
    printf("请输入字符串 buf：");
    scanf("%s", buf);  // 输入 "hello world"，只会读取 "hello"
    printf("buf = %s\n", buf);  // 输出：buf = hello

    char e[100] = {0};
    scanf("%s", e);  // 剩下的缓冲区中还有 "world"，会被读入 e
    printf("e = %s\n", e);  // 输出：e = world

    char tmp[100] = {0};
    printf("请输入字符串 tmp：");
    scanf("%s", tmp);  // 继续读取下一次输入
    printf("tmp = %s\n", tmp);
    
    return 0;
}

// 请输入字符串 buf：hello world
// buf = hello
// e = world
// 请输入字符串 tmp：c programming
// tmp = c
```

## 2.2 `gets()`：从标准输入中读取一行字符（包括空格），直到遇到换行符为止。

+ 函数签名 `char *gets(char *s);`
+ 注意事项：
    + 不安全！不检查缓冲区长度，可能发生缓冲区溢出。
    + 已在 C11 标准中被移除，推荐使用 fgets() 代替。

```c++
char buf[100];
printf("请输入一行字符串：");
gets(buf);
printf("buf = %s\n", buf);

// 请输入一行字符串：hello world
// buf = hello world
```

## 2.3 fgets()：从输入中读取一行字符串（可含空格），会保留换行符 `\n`

+ 函数签名 `char *fgets(char *str, int n, FILE *stream);`
+ 注意事项：
    + 会包含换行符 `\n`，需手动处理。
    + 读取字符数最大为 `n-1`，多出的会保留在缓冲区中。

```c++
char buf[10];
printf("请输入字符串（最多9字符）：");
fgets(buf, sizeof(buf), stdin);
printf("buf = '%s'\n", buf);

// 请输入字符串（最多9字符）：abcdefg
// buf = 'abcdefg\n'
```

## 2.4 puts()：向标准输出打印字符串并自动在末尾添加换行符。

+ 函数签名 `int puts(const char *s);`
+ 注意事项：
    + 自动添加换行符 `\n`，不需要手动添加。
    + 不能格式化输出（不像 printf）
    + 返回值为非负整数表示成功，负数表示错误。

```c++
char buf[] = "hello";
printf("%s", buf);     // 不换行
puts("hello, world");  // 自动换行
printf("good bye");

// hellohello, world
// good bye
```

## 2.5 fputs()：向指定文件流输出字符串，不自动添加换行符。

+ 函数签名 `int fputs(const char *s, FILE *stream);`
+ 注意事项：
    + 不自动添加换行符 `\n`，需要手动添加。
    + 常用于写文件或输出到 sterr。

```c++
char buf[] = "hello, world";
fputs(buf, stdout);  // 输出字符串

// hello, world
```

## 2.6 strlen()：计算字符串长度（不包括空终止符 `\0`）

+ 函数签名 `size_t strlen(const char *s);`

```c++
char buf[] = "hello, world";
printf("strlen = %lu\n", strlen(buf));       // 12
printf("sizeof = %lu\n", sizeof(buf));       // 13 (含 \0)

char buf2[] = "\0hello";
printf("strlen = %lu\n", strlen(buf2));      // 0
printf("sizeof = %lu\n", sizeof(buf2));      // 7


// strlen = 12
// sizeof = 13
// strlen = 0
// sizeof = 7
```

## 2.7 strcpy() / strncpy()：复制字符串

+ 函数签名
    + `char *strcpy(char *dest, const char *src);`
    + `char *strncpy(char *dest, const char *src, size_t n);`

+ 注意事项：
    + `strcpy` 不检查长度，易溢出
    + `strncpy` 可指定最大复制长度

```c++
char src[100] = "hello\0, world";
char dst[100];
strncpy(dst, src, 12);  // 拷贝前 12 字节
dst[0] = 'H';           // 修改首字符
printf("dst = %s\n", dst);
printf("strlen(dst) = %lu\n", strlen(dst));

// dst = Hello
// strlen(dst) = 5
```

## 2.8 strcmp() / strncmp()：比较两个字符串内容（逐字符 ASCII 比较）

+ 函数签名
    + `int strcmp(const char *s1, const char *s2);`
    + `int strncmp(const char *s1, const char *s2, size_t n);`
+ 注意事项
    + 区分大小写
    + 返回值：
        + `0：相等`
        + `<0：s1 < s2`
        + `>0：s1 > s2`

```c++
char a[100] = "hello, world";
char b[100] = "hello, World";

printf("strcmp = %d\n", strcmp(a, b));     // 区分大小写
printf("strncmp = %d\n", strncmp(a, b, 5)); // 前5个一样，返回0

// strcmp = 32
// strncmp = 0
```

## 2.9 strcat() / strncat()：将源字符串追加到目标字符串尾部

+ 函数签名
    + `char *strcat(char *dest, const char *src);`
    + `char *strncat(char *dest, const char *src, size_t n);`
+ 注意事项：
    + 会修改目标字符串
    + 注意是否有足够空间容纳拼接结果

```c++
char src[100] = "hello";
char dst[100] = "how are you?";
strncat(dst, src, 2);  // 追加前两个字符
printf("dst = %s\n", dst);

// dst = how are you?he
```

## 2.10 sprintf()：格式化输出到字符串

+ 函数签名 `int sprintf(char *str, const char *format, ...);`
+ 注意事项：
    + 与 `printf` 类似，但输出重定向到字符串

```c++
int a = 100;
char ch = 'a';
char buf[] = "hello";
char dst[100];
sprintf(dst, "a = %d, ch = %c, buf = %s\n", a, ch, buf);
printf("dst = %s", dst);

// dst = a = 100, ch = a, buf = hello
```

## 2.11 sscanf()：从字符串中读取格式化数据，可用来提取数字、字符串等

+ 函数签名 `int sscanf(const char *str, const char *format, ...);`

```c++
char str[] = "a = 1, b = 2, c = 3";
int a, b, c;
sscanf(str, "a = %d, b = %d, c = %d", &a, &b, &c);
printf("a = %d, b = %d, c = %d\n", a, b, c);

// a = 1, b = 2, c = 3
```

## 2.12：strchr() / strstr()：查找字符或子字符串在字符串中的位置

+ 函数签名
    + 查找字符：`char *strchr(const char *s, int c);`
    + 查找字符串：`char *strstr(const char *s1, const char *s2);`
+ 找到后返回首次出现位置的地址

```c++
char alpha[] = "hello, world";
char *s = strchr(alpha, 'w');
char *t = strstr(alpha, "world");
printf("s = %s\n", s);
printf("t = %s\n", t);

// s = world
// t = world
```

## 2.13 strtok()：分割字符串

+ 函数签名 `char *strtok(char *str, const char *delim);`

+ 注意事项：
    + 会修改原字符串，将分隔符替换成 `\0`
    + 第一次传原字符串，之后传 `NULL`

```c++
char alpha[100] = "one,two,three";
char *p = strtok(alpha, ",");
while (p != NULL) {
    printf("token = %s\n", p);
    p = strtok(NULL, ",");
}

// token = one
// token = two
// token = three
```

## 2.14 atoi() / atof() / atol()：将字符串转换为对应类型的数值（int、float、long）

+ 函数签名
    + `int atoi(const char *str);`
    + `float atof(const char *str);`
    + `long atol(const char *str);`
+ 注意事项：
    + 遇到非数字字符或 \0 就停止解析

```c++
char str1[] = "   +10";
int num1 = atoi(str1);
char str2[] = "0.123";
double num2 = atof(str2);
printf("num1 = %d, num2 = %lf\n", num1, num2);

// num1 = 10, num2 = 0.123000
```











