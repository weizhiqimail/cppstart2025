# 1. 结构体

结构体（struct）是C语言中用于组合多种数据类型的自定义类型。

```c++
#include <stdio.h>
#include <iostream>

using namespace std;

// struct 结构体
void structWeaponFn() {
    struct Weapon {
        char name[20];
        int atk;
        int price;
    };

    struct Weapon weapon = {"ak47", 100, 200};
    printf("structWeaponFn 访问单个 weapon 结构体的成员\n");
    printf("weapon.name = %s\n", weapon.name);
    printf("weapon.atk = %d\n", weapon.atk);
    printf("weapon.price = %d\n", weapon.price);
    printf("weapon.price++\n");
    printf("weapon.price = %d\n", weapon.price);
    printf("\n");

    struct Weapon weapons[2] = {
        {"AK47", 100, 200},
        {"AK48", 70, 120}
    };

    printf("structWeaponFn 访问 weapons 数组结构体的成员\n");
    for (int i = 0; i < 2; i++) {
        printf("Weapon[%d]: %s, ATK: %d, Price: %d\n",
               i, weapons[i].name, weapons[i].atk, weapons[i].price);
    }

    printf("\n");
}

// typedef 定义结构体类型
void typedefWeaponFn() {
    typedef struct {
        char name[20];
        int atk;
        int price;
    } Weapon;
    Weapon weapon = {"AK47", 100, 200};
    printf("typedefWeaponFn 访问 weapon 结构体的成员\n");
    printf("weapon.name = %s\n", weapon.name);
    printf("weapon.atk = %d\n", weapon.atk);
    printf("weapon.price = %d\n", weapon.price);
    printf("weapon.price++\n");
    printf("weapon.price = %d\n", weapon.price);
    printf("\n");
}

// 指针访问结构体
void structWeaponPointerFn() {
    struct weapon {
        char name[20];
        int atk;
        int price;
    };

    printf("structWeaponPointerFn 通过指针取值\n");

    // w1 代表一个结构体变量，&w1 代表一个结构体变量的地址
    struct weapon w1 = {"AK47", 100, 200};
    printf("w1 的地址: %p\n", &w1);

    // 指针变量 p 指向结构体变量 w1 的地址
    // 如果要指向 w2，需要 p = &w2;
    struct weapon *p = &w1;
    printf("*p 的地址: %p\n", p);

    printf("通过指针取值 p->name = %s\n", p->name); // 箭头运算符
    printf("通过引用取值 (*p).name = %s\n", (*p).name); // 点运算符

    struct weapon arr[2] = {{"AK47", 100, 200}, {"AK48", 70, 120}};
    p = arr;
    printf("Arr[0]: %s\n", p->name);
    // p++ 移动的字节数等于 sizeof(struct weapon)，体现了指针的步长特性。
    p++; // 移动到下一个结构体
    printf("移动到下一个结构体 p++\n");
    printf("Arr[1]: %s\n", p->name);
}

int main() {
    structWeaponFn();
    typedefWeaponFn();
    structWeaponPointerFn();
    return 0;
}

```

# 2. 共用体类型 

## 2.1 共用体

+ 共用体（union）允许多个成员共享同一块内存空间。共用体的大小是其最大成员的大小。
+ 特点
  + 所有成员共用同一个地址。
  + 同一时刻只能存储一个成员的值。
+ 大小：等于最大成员的大小。（对齐）
+ 用途：节省内存，处理多类型数据。


## 2.2 共用体示例

```c++
#include <stdio.h>

union data {
    int a;
    char b;
    double c; // 增加 double 测试对齐
};

int main() {
    union data d = {10}; // 仅初始化一个成员
    printf("a = %d\n", d.a); // 输出: 10
    d.b = 'x'; // 覆盖之前的 a
    printf("b = %c\n", d.b); // 输出: x
    printf("Size of union: %zu\n", sizeof(d)); // 输出: 8（因 double 对齐）
    return 0;
}
```

# 3. 内存对齐

+ 结构体对齐规则：
  + 结构体变量的首地址是最长成员长度的整数倍。
  + 每个成员相对结构体首地址的偏移量，一定是该成员长度的整数倍。
  + 结构体的总长度是最长成员长度的整数倍。
  + 如果结构体内有成员长度大于处理器的位数，那么就以处理器的位数作为对齐单位。
  + 总大小是最大基本类型（比如 `int`，4字节）的倍数。
+ 对齐之后，还需要计算出结构体的大小。

## 3.1 示例代码 1 对齐

```c++
#include <iostream>

using namespace std;

int main() {
    struct User1 {
        short a;    // 2
        char b;     // 1
        double c;   // 8
    };

    cout << sizeof(User1) << endl; // 16

    return 0;
}
```

```text
文字图解析

+--------+--------+--------+--------+--------+--------+--------+--------+
|  a (2) |  b (1) |  pad   |                 c (8 bytes)                 |
+--------+--------+--------+--------+--------+--------+--------+--------+
|   0    |   2    |   3    |   4    |   5    |   6    |   7    |   8~15 |
+--------+--------+--------+--------+--------+--------+--------+--------+

说明：
- a: short，2 字节
- b: char，1 字节
- pad: 5 字节填充，为了让 double 对齐到地址 8
- c: double，8 字节，从偏移 8 开始

所以总长为 16.
```

## 3.2 示例代码 2 对齐

```c++
#include <iostream>

using namespace std;

int main() {
    struct User2 {
        short a;    // 2
        double c;   // 8
        char b;     // 1
    };

    cout << sizeof(User2) << endl; // 24
    return 0;
}
```

```text
+--a(2)--+-------padding(6)-------+----------c(8)----------+--b(1)--+----padding(7)----+
|  0~1   |        2~7             |        8~15            | 16     |     17~23        |

说明：
- a: short，2 字节
- pad: 6 字节填充，为了让 double 对齐到地址 8
- c: double，8 字节，从偏移 8 开始
- b: char，1 字节，偏移 16
- 尾部 pad: 7 字节，结构体总大小对齐到 8 的倍数

所以总长为 24.
```

# 4. 动态数据结构

## 4.1 静态数据结构 vs 动态数据结构

+ 静态：如数组，固定大小和地址。
+ 动态：如链表，地址不连续，可动态扩展。

## 4.2 静态链接

```c++
#include <stdio.h>

struct weapon {
    int price;
    int atk;
    struct weapon *next;
};

int main() {
    struct weapon a = {100, 100, NULL};
    struct weapon b = {200, 200, NULL};
    struct weapon c = {300, 300, NULL};
    a.next = &b;
    b.next = &c;

    struct weapon *p = &a;
    while (p) {
        printf("Price: %d, ATK: %d\n", p->price, p->atk);
        p = p->next;
    }
    return 0;
}
```

## 4.3 动态链接

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h> // 用于 srand 和 rand

struct weapon {
    int price;
    int atk;
    struct weapon *next;
};

// 释放链表内存
void free_list(struct weapon *head) {
    struct weapon *p = head;
    while (p != NULL) {
        struct weapon *next = p->next;
        free(p);
        p = next;
    }
    printf("链表内存已释放。\n");
}

// 创建动态链表，接受 size 参数作为 malloc 分配的大小
struct weapon *create(int size, int node_count) {
    struct weapon *head = NULL, *p1, *p2 = NULL;
    int n = 0;

    // 检查 size 是否足够容纳 struct weapon
    if (size < sizeof(struct weapon)) {
        printf("错误：分配大小 %d 小于 struct weapon 所需 %zu 字节\n", size, sizeof(struct weapon));
        return NULL;
    }

    // 初始化随机数种子
    srand((unsigned) time(NULL));

    // 创建指定数量的节点
    for (int i = 0; i < node_count; i++) {
        p1 = (struct weapon *) malloc(size);
        if (!p1) {
            printf("内存分配失败！\n");
            free_list(head); // 释放已分配的部分
            return NULL;
        }

        // 随机生成 price 和 atk（范围示例：1-1000）
        p1->price = rand() % 1000 + 1; // 1 到 1000
        p1->atk = rand() % 1000 + 1;

        if (n++ == 0) {
            head = p1; // 第一个节点作为头
        } else {
            p2->next = p1; // 链接到上一个节点
        }
        p2 = p1; // 更新上一个节点
    }

    // 设置链表尾
    if (p2) {
        p2->next = NULL;
    }

    return head;
}

// 打印链表内容
void print_list(struct weapon *head) {
    struct weapon *p = head;
    printf("链表内容:\n");
    while (p != NULL) {
        printf("Price: %d, ATK: %d\n", p->price, p->atk);
        p = p->next;
    }
}


int main() {
    struct weapon *p;
    int alloc_size = sizeof(struct weapon); // 分配大小
    int node_count = 5; // 生成 5 个节点

    printf("使用分配大小: %d 字节，生成 %d 个节点\n", alloc_size, node_count);
    p = create(alloc_size, node_count);
    if (p) {
        print_list(p);
        free_list(p);
    } else {
        printf("链表创建失败。\n");
    }

    return 0;
}

```














