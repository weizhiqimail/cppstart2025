# 1. C 程序介绍

## 1.1 C 语言的版本

+ **K&R C**

在 1978 年，Kernighan 和 Ritchie 的《The C Programming Language》第一版出版,一直被广泛作为 C 语言事实上的规范,称 K&R C;

+ **ANSI C 和 ISO C**

1989年，C 语言被 ANSI 标准化,对 K&R C 进行了扩展,包括了一些新特性,也规定了一套标准函数库;

ISO 成立 WG14 工作组来规定国际标准的 C 语言,通过对 ANSI 标准的少量修改,最终通过了 ISO 9899:1990，随后 ISO 标准被 ANSI 采纳;

+ **C99**

在 ANSI 标准化后，WG14 小组继续致力于改进 C 语言，新的标准很快推出，就是 ISO9899:1999 (1999年出版)，这个版本就是通常提及的 C99，被 ANSI 于 2000 年三月采用;

+ **C11**

2011 年 12 月 8 日，ISO 正式公布 C 语言的新的国际标准草案: ISO/IEC1988:2001，即C11;

## 1.2 特别说明

+ **C语言规范定义得非常宽泛**

long型数据长度不短于int型

short型不长于int型

+ **导致的结果**

相同的程序在不同编译器上具有不同的解释结果。

相同的程序在不同平台上运行结果不同。

例如：整型变量定义、对 `++`，`--` 的解释、输入输出赋值顺序的不同、浮点数计算精度的不同。

**但是，只要坚持使用标准形式，把程序从一个编译器移植到另一个编译器，就不会出现什么问题。**

## 1.3 程序设计语言的构成
+ **数据成分**，用于描述程序中所设计的数据。有哪些数据类型？如何使用？
+ **运算成分**，用于描述程序中所包含的运算。有哪些运算符号？如何使用？
+ **控制成分**，用于描述程序中的控制构造。三种类型的控制语句是如何写的？
+ **传输成分**，用于描述程序中数据的传输。在程序中如何输入和输出数据？

## 1.4 程序编译步骤

+ **预处理**：宏定义展开、头文件展开、条件编译等，通过是将代码中的注释删除，这里并不会检查语法
  + `.c 文件--> .i 文件`：`gcc -E hello.c -o hello.i`
  + 就是把头文件，宏全部都 **copy** 到它所对应的位置
  + **宏的本质就是替换**
    + 只要符合 C 语言的语法，预处理器就会把它替换掉，不在乎其形式。
    + 所以就算代码里所有错误，也可以正常进行预处理。
+ **编译**：检查语法，将预处理后文件编译成汇编文件
  + `.i 文件--> .s 文件`：`gcc -S hello.i -o hello.s`
+ **汇编**：将汇编文件生成目标二进制文件
  + `.s 文件--> .o 文件`：`gcc -c hello.s -o hello.o`
  + 生成目标文件，但是目标文件不能执行
+ **链接**：C 语言写的程序时需要依赖各种库，所以编译之后还需要把库链接到最终的可执行程序中去
  + `.o 文件--> .out 可执行文件`：`gcc hello.o -o hello.out`

## 1.5 gcc 的命令行参数

+ **参数**
    + `-E` 只进行预处理
    + `-S` 只进行预处理和编译
    + `-c` 只进行预处理、编译和汇编
    + `-o <filename>` 执行生成的输出文件为 filename
+ **文件后缀**
    + `.c` C 语言文件
    + `.i` 预处理器后的 C 语言文件
    + `.s` 编译后的汇编文件
    + `-o` 编译后的目标文件

## 1.6 编译器的任务

编译是将高级程序设计语言编写的源代码，转换成目标平台的机器语言代码的过程。

对于 C 语言或者其他语言，编译器的编译工作一般分为两个步骤，编译和链接。

**编译是将源代码转换成目标代码的过程。目标代码文件不是一个完整的可执行文件，其中还缺少库代码和启动代码。**

目标代码文件必须**通过链接器将中间代码和其他运行库代码合并**才能形成目标平台的可执行文件。

## 1.7 链接器的任务

通过编译器和链接器的分步编译，首先能够提高代码的**可重用性**和**代码的可移植性**。

其次，也能够**提高编译效率**。原有系统库代码可以不编译，部分无修改的代码也可以直接使用原有的目标文件，直接通过高效率的链接形成可执行文件。

## 1.8 `main` 函数的参数，即命令行参数

+ GCC 的编译命令无法直接嵌入运行参数，参数传递必须在运行阶段完成。
+ 通过 gcc 编译为 exe 文件后可以执行，调用 `sample.exe para1 para2` 即可在 `main` 函数中获取到参数。
+ `argc` 的含义：
  + `argc` 是 `Argument Count` 的缩写，表示程序启动时命令行参数的总数。 
+ 特点： 
  + C/C++ 规定，可执行程序的文件名本身算作第一个参数，因此 `argc` 的最小值始终为 `1`（即使未提供额外参数）。 
  + 例如，运行 `sample.exe para1 para2` 时，`argc = 3（包括 sample.exe）`。

+ `argv` 的含义：
  + `argv` 是 `Argument Vector` 的缩写，是一个指针数组（`char *argv[]`），每个元素是一个指向字符串的指针（c`har *`）。

+ 作用： 
  + 存储命令行中传入的所有参数（包括程序名）。 
  + 每个字符串以 `\0` 结尾，表示一个完整的参数。

+ 示例： 
  + 命令：sample.exe para1 para2 s.txt 5 "hello world"
  + argv 内容：
    + `argv[0]` = `sample`（程序名）
    + `argv[1]` = `para1`
    + `argv[2]` = `para2`
    + `argv[3]` = `s.txt`
    + `argv[4]` = `5`
    + `argv[5]` = `hello world`

```c++
#include <stdio.h>

// 主函数，接收命令行参数
// argc: 参数总数（包括程序名）
// argv: 指针数组，存储每个参数的字符串
int main(int argc, char *argv[]) {
    // 打印参数总数
    printf("Total number of arguments: %d\n", argc);
    
    // 遍历 argv 数组，逐个打印每个参数
    printf("Command line arguments:\n");
    for (int i = 0; i < argc; i++) {
        // argv[i] 是第 i 个参数的字符串
        printf("argv[%d] = %s\n", i, argv[i]);
    }
    
    // 添加分隔线，提升可读性
    printf("------------------------\n");
    
    return 0;
}
```

## 1.9 代码风格




# 2. 基本操作

## 2.1 数据类型

+ 基本类型
  + 整型 `int` `short` `long`
  + 字符型 `char`
  + 实型(浮点型)
    + 单精度实型 `float`
    + 双精度实型 `double`
+ 构造类型
  + 数组类型
  + 结构类型 `struct`
  + 联合类型 `union`
  + 枚举类型 `enum`
+ 指针类型 `char *`, `int *`, `int **` 等

## 2.2 进制
+ 数据在计算机中主要是以补码的形式存储的
+ 进制赋值与显示

```c++
// 十进制赋值
int a = 12;

// 八进制赋值
int b = 01234567;

// 十六进制赋值
int c = 0xa1;

// 十进制显示
printf("%d\n", a);

// 八进制显示
printf("%o\n", a);

// 十六进制
printf("%x\n", a);
```

## 2.3 有符号和无符号

+ 有符号，最高位是符号位，1 代表负数，0 代表正数
+ 无符号，最高位不是符号位，是数的一部分，无符号不可能是负数

```c++
int b = 0x8000007b;

printf("%d\n", b); // -2147483525
printf("%u\n", b); // -2147483771
```

+ int 默认是有符号，所以 `signed int a = -10;` 等价于 `int a = -10;`
+ 无符号不能赋值为负数
+ `%d` 是有符号输出，`%u` 是无符号输出
+ 无符号的数字不能通过 `%d` 输出

## 2.4 char
+ 一个 char 字符占一个字节
+ 无符号范围：`0~255`
+ 有符号范围：`-128~127`
+ 赋值或运算，不要越界

```c++
char a = 127 + 2;
printf("%d", a); // -127

// 129
// 原码：1000 0001，这是一个负数
// 反码：1111 1110
// 补码：1111 1111，所以是 -127

---------------------------------
unsigned char b = 255 + 2;
printf("%u\n", b); // 1
```

## 2.5 `sizeof` & `typedef`

### 2.5.1 `sizeof`
+ 运算符，功能是计算一个数据类型的大小，单位为字节

```c++
printf("sizeof(char) = %u\n", sizeof(char));   // 1
printf("sizeof(short) = %u\n", sizeof(short)); // 2
printf("sizeof(int) = %u\n", sizeof(int));     // 4
unsigned short a = 9;
printf("sizeof(a) = %u\n", sizeof(a));         // 2
printf("a = %u\n", a);                         // 9
```

### 2.5.2 `typedef`

+ 作用是给变量类型起别名
+ `typedef` 是 C 语句，要以分号结尾
+ `typedef` 是有作用域的，而 `define` 宏是没有作用域的
+ `typedef` 不会被预处理
+ 通常是给自定义的数据类型起一个别名
+ `size_t` 就是系统起的名字，全称是 `typedef unsigned long size_t`

```c++
typedef int tni;

// 给 int * 类型起了别名 p
typedef int *p;

// 定义 int * 类型，就可以这么写
p q = 1;
```

## 2.6 整型

### 2.6.1 整型输出

+ `%d`，输出一个有符号的 `10` 进制 `int` 型
+ `%o`，输出一个 `10` 进制 `int` 型
+ `%x`，输出一个 `16` 进制 `int` 型，字母小写
+ `%X`，输出一个 `16` 进制 `int` 型，字母大写
+ `%u`，输出一个 `10` 进制的无符号数
+ `%hd`，输出 `short` 类型
+ `%d`，输出 `int` 类型
+ `%l`，输出 `long` 类型
+ `%ll`，输出 `long long` 类型
+ `%hu`，输出 `unsigned short` 类型
+ `%u`，输出 `unsigned int` 类型
+ `%lu`，输出 `unsigned long` 类型
+ `%llu`，输出 `unsigned long long` 类型

### 2.6.2 所占字节

+ `short` 短整型，`2` 字节
+ `int` 整型，`4` 字节
+ `long` 长整型，`windows 为 4 字节，Linux 为 4 字节(32位)，8 字节(64位)`
+ `long long` 长长整型，`8` 字节

+ **注意**
  + 整型数据在内存中所占的字节数与所选择的操作系统有关。C 语言标准没有明确规定整形数据的长度，但是 long 类型整数的长度不能短于 int 类型，short 类型整数的长度不能长于 int 类型
  + 当一个小的数据类型赋值给一个大的数据类型，不会出错，因为编译器会自动转化。但是当一个大的类型赋值给一个小的数据类型，那么就有可能会丢失高位

## 2.7 字符类型
+ 一个数字，对应一个字符。
+ 使用字符或者数字给字符变量赋值是完全等价的
+ **字符类型本质上就是给字节大小的整型**
+ 实际上就是说如果把一个 char 类型变量赋值为数字，那么这个变量默认会去 ascii 表里找这个数字对应的字符，如果这个数字不在 ascii 里，那么变量的值就是乱码
+ 字符原则上内部只有一个字符，但是转义字符不是，转义字符由反斜线组成的多个字符
+ 转义字符
  + `\n` 换行
  + `\b` 退格，删掉前一个字符
  + `\r` 光标切到句首，句首前边的字符都被覆盖掉了
  + `\0` 就是 0

```c++
char ch = 'a';
// ch = a, ch = 97
printf("ch = %c, ch = %d \n", ch, ch);

ch = 97;
// ch = a
printf("ch = %c\n", ch);

// \b 是退格符
ch = '\b';
// abdef
printf("abc%cdef\n", ch);

// \r 是回车符，光标回到行首。
ch = '\r';
// def
printf("abc%cdef\n", ch);
```

## 2.8 浮点数
+ 数据精度不准确

```c++
float a = 100.9f;
printf("%f\n", a);
// 100.900002

printf("请输入 float: ");
// 请输入 float:98.22
scanf("%f", &a);
printf("%f\n", a);
// 98.220001
```

## 2.9 类型限定符
+ `extern` 声明一个变量，`extern` 声明的变量没有建立存储空间
+ `const` 定义一个常量，常量的值不能修改
+ `volatile` 防止编译器优化代码
+ `register` 定义寄存器变量，提高效率。
  + register 是建议型的指令，而不是命令型的指令。
  + 如果 CPU 有空闲寄存器，那么 register 就生效。
  + 如果没有空闲寄存器，那么 register 就无效。

## 2.10 运算符优先级
+ 优先级为 1
  + `[]` 数组下标
  + `()` 圆括号
  + `.` 成员选择(对象)
  + `->` 成员选择(指针)

+ 优先级为 2
  + `-` 负号运算符
  + `~` 按位取反运算符
  + `++` 自增运算符
  + `--` 自减运算符
  + `*` 取值运算符
  + `&` 取地址运算符
  + `!` 逻辑非运算符
  + `(类型)` 强制类型转换运算符
  + `sizeof` 长度运算符

+ 优先级为 3
  + `/` 除法
  + `*` 乘法
  + `%` 余数(取模)
  + `+` 加法

## 2.11 C 语言类型转换

+ 特点
  + 简单直接，但不安全。 
  + 不区分转换的语义，可能隐藏错误（如指针类型转换）。

### 2.11. 隐式转换

+ 隐式转换 ：编译器自动进行的类型转换
+ 例如：`int` 转为 `float`，`float` 转为 `double`
+ 小范围类型转换为大范围类型（如 int 到 float）。 
+ 有符号到无符号可能导致未定义行为。

```c++
int i = 10;
float f = i;       // 隐式转换：int 转为 float
double d = 5.25;   // double 类型
int j = d;         // 隐式转换：double 转为 int，截断小数部分

printf("int to float: %f\n", f);  // 输出 10.000000
printf("double to int: %d\n", j); // 输出 5
```

### 2.11.2 显式转换：
+ 使用 C 风格的强制转换 (type)，手动指定目标类型。 
+ 语法：(目标类型) 表达式。

```c++
double d = 3.14159;
int i = (int)d;         // 显式转换：double 转为 int，截断小数
char c = (char)65;      // 显式转换：int 转为 char，65 是 'A'

printf("double to int: %d\n", i);  // 输出 3
printf("int to char: %c\n", c);    // 输出 A
```

## 2.12 C++ 中的类型转换

### 2.12.1 C++ 风格转换
+ C++ 继承了 C 的隐式和显式转换，但引入了四种更现代、更安全的显式转换方式，称为 C++ 风格转换： 
  + static_cast 
  + dynamic_cast 
  + const_cast 
  + reinterpret_cast

### 2.12.2 C++ 风格显式转换：static_cast

+ 用于“安全”的基本类型转换或类层次中的向上转换（`upcast`）。 
+ 不执行运行时类型检查。

```c++
#include <iostream>
using namespace std;

int main() {
    double d = 9.99;
    int i = static_cast<int>(d); // double 转为 int，截断小数

    cout << "double to int: " << i << endl; // 输出 9

    // 指针转换（向上转换）
    class Base {};
    class Derived : public Base {};
    Derived derived;
    Base* basePtr = static_cast<Base*>(&derived); // 安全向上转换

    return 0;
}
```

### 2.12.3 C++ 风格显式转换：dynamic_cast

+ 用于多态类型（含虚函数）的指针或引用的向下转换（`downcast`），运行时检查类型。 
+ 需要运行时类型信息（RTTI），失败时返回 `nullptr`（指针）或抛出异常（引用）。

```c++
#include <iostream>
using namespace std;

class Base {
public:
    virtual void foo() {} // 虚函数启用多态
};
class Derived : public Base {};

int main() {
    Base* base = new Derived();
    Derived* derived = dynamic_cast<Derived*>(base); // 向下转换

    if (derived) {
        cout << "Downcast successful\n"; // 输出此行
    } else {
        cout << "Downcast failed\n";
    }

    delete base;
    return 0;
}
```

### 2.12.4 C++ 风格显式转换：const_cast

+ 用于添加或移除变量的 `const` 或 `volatile` 属性。 
+ 常用于修改 `const` 对象（需谨慎，可能引发未定义行为）。
+ 修改 `const` 对象可能是未定义行为，取决于编译器优化。

```c++
#include <iostream>
using namespace std;

void modify(int* ptr) {
    *ptr = 100;
}

int main() {
    const int val = 42;
    int* ptr = const_cast<int*>(&val); // 移除 const
    modify(ptr);

    cout << "Modified value: " << *ptr << endl; // 输出 100（但 val 仍可能是 42，未定义行为）

    return 0;
}
```


### 2.12.5 C++ 风格显式转换：reinterpret_cast

+ 用于低级别的类型转换（如指针类型之间的转换），非常不安全，仅用于特殊场景。 
+ 不改变底层位模式，只重新解释类型。

```c++
#include <iostream>
using namespace std;

int main() {
    int i = 65;
    char* c = reinterpret_cast<char*>(&i); // int* 转为 char*

    cout << "int as char: " << *c << endl; // 输出 A（65 的 ASCII）

    return 0;
}
```

### 2.12.6 总结

+ C：尽量使用显式转换 (type)，避免隐式转换导致的意外。
+ C++： 
  + 优先使用 C++ 风格转换（如 static_cast），提高代码可读性和安全性。 
  + 根据需求选择合适的转换类型： 
    + 基本类型转换：`static_cast`。 
    + 多态类型转换：`dynamic_cast`。 
    + 修改 const：`const_cast`。 
    + 低级转换：`reinterpret_cast`。
