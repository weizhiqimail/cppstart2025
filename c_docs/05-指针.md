# 1. 指针

## 1.0 理解指针

+ 变量地址源代码

```c++
int x = 10;
int *p = &x;
*p = 20;
```
+ 变量地址内存模型图

```text
变量        值           地址（假设）      说明
------     --------     ------------     ------------------------------------
x          10->20       0x1000           x 是一个普通的整数变量。开始是10，*p 修改后变成20
p          0x1000       0x2000           p 是一个指针变量，指向 x 的地址
*p         20           —                *p 表示指针 p 指向的值（即 x）
&p         0x2000       —                &p 是 p 的地址，即 0x2000
&x         0x1000       —                &x 是 x 的地址，即 0x1000
```

+ 指针在函数参数传递
  + `modify(&x)` 表示把变量 x 的地址传递给函数 modify。
  + modify 方法有一个参数 `int *a`，表示参数是一个指针。
  + 在 modify 函数内执行 `*a=999`，表示把 参数 a 的地址所指向的值，修改为 999。

+ 函数参数传递示例

```c++
// 函数参数传递
void modify(int *a) {
    *a = 999;  // 通过指针修改函数外部的变量
}

int main() {
    int x = 10;  // 声明整数 x，值为 10
    modify(&x);  // 传递 x 的地址给函数 modify
    printf("x = %d\n", x);  // 输出 x 的值，应该是 999
}
```

+ 函数参数传递内存模型图

```text
变量        值           地址（假设）      说明
------     --------     ------------     ------------------------------------
x          10->999      0x1000           x 是一个普通的整数变量，最初值为 10。调用 modify 后变成 999。
a          0x1000       0x3000           a 是 modify 函数的参数，指向 x 的地址
*p         999          —                *p 修改了指针 a 所指向的内容，即修改了 x 的值
&a         0x3000       —                &a 是参数 a 在函数中的地址
&x         0x1000       —                &x 是 x 的地址，传递给了函数 modify
```


## 1.1 指针
+ 直接操作指针变量没有意义。
+ 需要操作 `*p` 才能指定指针所指向的内存。
+ **普通变量把值作为基本量，把地址作为通过 `&` 运算符获得的派生量。**
+ **指针变量把地址作为基本量，把值作为通过 `*` 运算获得的派生量。**

## 1.2 野指针
+ 指针变量保存了一个没有意义的地址，就是非法地址。
+ 只有定义后的变量，此变量的地址才是合法的地址。
+ 野指针就是一个保存没有意义地址的指针变量。
+ 操作野指针变量本身不会有问题，但是操作野指针所指向的内存才会导致段错误。

## 1.3 空指针
+ 空指针，给指针变量赋值为 `NULL`，`NULL` 就是 `0`

## 1.4 指针大小
+ 32 位编译器用 32 位大小(4字节)保存地址
+ 64 位编译器用 64 位大小(8字节)保存地址

```c++
#include <stdio.h>

int main () {
    int a = sizeof(int *);
    int b = sizeof(char *);

    double *p;
    int c = sizeof(p);
    printf("a = %d\n", a);  // a = 8
    printf("b = %d\n", b);  // a = 8
    printf("c = %d\n", c);  // a = 8
    return 0;
}
```

## 1.5 `[]` 与数组
+ 指针 `p[0]` 可以修改原值

```c++
#include <stdio.h>

int main () {
    int a = 100;
    int *p = &a;
    *p = 200;

    printf("a = %d\n", a);          // a = 200
    printf("p[0] = %d\n", p[0]);    // p[0] = 200
    
    p[0] = 300;
    printf("a = %d\n", a);          // a = 300
    return 0;
}
```

## 1.6 万能指针

+ 不可以定义 `void` 类型的变量，因为不能确定类型，不同的类型做占字节长度不同。
+ 可以定义 `void *变量` 指针，这种指针叫做万能指针。
+ `void *` 可以指向任何类型的变量，使用指针所指向的内存时，最好转换为它本身的指针类型。

```c++
#include <stdio.h>

int main () {
    void *p = NULL;
    int a = 100;
    p = &a;

    // 强制转换指针类型
    *((int *) p) = 200;
    printf("%d\n", *((int *) p));   // 200
    return 0;
}
```

## 1.7 指针步长

+ 步长由指针指向的数据类型决定
+ int * 指向 int 类型，操作内存时，操作 4 字节
+ char * 指向 char 类型，操作内存时，操作 1 字节


## 1.8 const 修饰指针

**`const` 修饰指针时，其作用取决于 `const` 的位置，共有以下三种情况：**

+ `const` 在 `*` 之前（`const int *` 或 `int const *`）
    + 功能：限制 `*ptr`，即指针指向的值为常量，不能通过该指针修改指向的值。
    + 特点：指针本身（`ptr`）可以改变指向其他地址，但不能修改所指对象的值。
    + 示例：`const int *a` 表示 `*a` 是只读的，但 `a` 可以重新指向其他地址。

+ `const` 在 `*` 之后（`int * const`）
    + 功能：限制 `ptr`，即指针本身为常量，不能改变指向的地址。
    + 特点：指针必须在声明时初始化，且不可重新赋值，但可以通过指针修改所指对象的值。
    + 示例：`int * const h` 表示 `h` 固定指向某地址，但 `*h` 可以被修改。

+ `const` 同时在 `*` 前后（`const int * const`）
    + 功能：同时限制 `ptr` 和 `*ptr`，即指针本身和指向的值均为常量。
    + 特点：指针必须初始化，既不能改变指向的地址，也不能修改所指对象的值。
    + 示例：`const int * const p` 表示 `p` 和 `*p` 都是只读的。

+ `int const *` 与 `const int *` 的等价性
    + 这两者完全相同，`const 在 int` 前后但在 `*` 前时，效果一致，都限制 `*ptr` 为只读。

```c++
#include <stdio.h>

int main() {
    // 示例 1：const 在 * 之前，限制 *ptr（指向的值）
    int y = 1;
    const int *a = &y;  // a 指向一个 const int，不能通过 a 修改 y
    printf("y = %d\n", y);        // 输出: y = 1
    printf("*a = %d\n", *a);      // 输出: *a = 1
    // *a = 2;                   // 错误：不能通过 a 修改 y 的值
    y = 3;                       // 正确：可以通过 y 本身修改
    printf("y = %d\n", y);        // 输出: y = 3
    printf("*a = %d\n", *a);      // 输出: *a = 3
    int x = 5;
    a = &x;                      // 正确：a 可以改变指向
    printf("*a = %d\n", *a);      // 输出: *a = 5

    printf("\n");

    // 示例 2：const 在 * 之后，限制 ptr（指针本身）
    int m = 10;
    int * const h = &m;          // h 是常量指针，必须初始化，不能改变指向
    printf("m = %d\n", m);        // 输出: m = 10
    printf("*h = %d\n", *h);      // 输出: *h = 10
    *h = 20;                     // 正确：可以通过 h 修改 m 的值
    printf("m = %d\n", m);        // 输出: m = 20
    printf("*h = %d\n", *h);      // 输出: *h = 20
    // h = &x;                   // 错误：h 不能改变指向

    printf("\n");

    // 示例 3：const 同时在 * 前后，限制 ptr 和 *ptr
    int z = 30;
    const int * const p = &z;    // p 和 *p 都是常量，必须初始化
    printf("z = %d\n", z);        // 输出: z = 30
    printf("*p = %d\n", *p);      // 输出: *p = 30
    // *p = 40;                  // 错误：不能通过 p 修改 z 的值
    // p = &x;                   // 错误：p 不能改变指向
    z = 50;                      // 正确：可以通过 z 本身修改
    printf("z = %d\n", z);        // 输出: z = 50
    printf("*p = %d\n", *p);      // 输出: *p = 50

    printf("\n");

    // 示例 4：int const * 和 const int * 等价性验证
    int k = 100;
    int const *q = &k;           // 等价于 const int *q
    printf("k = %d\n", k);        // 输出: k = 100
    printf("*q = %d\n", *q);      // 输出: *q = 100
    // *q = 200;                 // 错误：不能通过 q 修改 k 的值
    k = 300;                     // 正确：可以通过 k 本身修改
    printf("k = %d\n", k);        // 输出: k = 300
    printf("*q = %d\n", *q);      // 输出: *q = 300
    q = &x;                      // 正确：q 可以改变指向
    printf("*q = %d\n", *q);      // 输出: *q = 5

    return 0;
}
```

# 2. 函数指针

## 2.1 基本概念

程序运行时，每个函数占用一段连续的内存空间，函数名即该函数的入口地址（起始地址）。

通过将函数地址赋值给一个指针变量，可以创建 **函数指针**，从而通过该指针调用函数。

函数指针常用于**动态调用函数**或作为**回调函数传递给其他函数**（如 qsort）。

## 2.2 定义函数指针的形式

+ 形式：`类型名 (*指针变量名)(参数类型1, 参数类型2, ...)`
+ 说明： 
  + `类型名`：函数返回值的类型。
  + `*指针变量名`：表示这是一个指针，指向函数。
  + `(参数类型1, 参数类型2, ...)`：指定函数的参数类型列表。
+ 示例：`int (*pf)(int, char)`
  + `pf` 是一个**函数指针**，指向的函数返回 `int`，接收一个 `int` 和一个 `char` 参数。

## 2.3 使用方法

+ 赋值：将匹配原型（返回值和参数类型一致）的函数名赋值给函数指针，无需取地址符 `&`，因为函数名本身就是地址。
+ 调用：通过 `函数指针名(实参表)` 调用函数，等价于直接调用原函数。
+ 注意：**若需通过函数修改实参值，必须使用地址传递（指针参数）**。

## 2.4 基本函数指针使用

```c++
#include <stdio.h>

// 定义一个函数 PrintMin，比较两个整数并打印较小值
void PrintMin(int a, int b) {
    if (a < b) {
        printf("%d\n", a);
    } else {
        printf("%d\n", b);
    }
}

int main() {
    // 声明函数指针 pf，指向返回 void 且接收两个 int 参数的函数
    void (*pf)(int, int);
    
    // 定义两个整数变量
    int x = 4, y = 5;
    
    // 将 PrintMin 函数地址赋值给 pf
    pf = PrintMin;
    
    // 通过函数指针调用 PrintMin，传入 x 和 y
    pf(x, y);  // 输出: 4
    
    return 0;
}
```

## 2.5 通过地址传递修改实参

```c++
#include <stdio.h>

// 定义 swap 函数，使用异或运算交换两个整数的值
void swap(int *a, int *b) {
    *a = *a ^ *b;  // 异或操作：a 存 a 和 b 的异或结果
    *b = *a ^ *b;  // b 变为原 a 的值
    *a = *a ^ *b;  // a 变为原 b 的值
}

int main() {
    // 定义两个整数变量
    int a = 3, b = 5;
    
    // 打印交换前的值
    printf("Before: a = %d, b = %d\n", a, b);
    
    // 调用 swap 函数，传入 a 和 b 的地址
    swap(&a, &b);
    
    // 打印交换后的值
    printf("After: a = %d, b = %d\n", a, b);
    
    return 0;
}
```

## 2.6 函数指针与 `qsort` 库函数

+ `qsort` 是 C 标准库中的快速排序函数，通过函数指针实现灵活的比较规则，可对任意类型数组排序。
+ 函数签名：`void qsort(void *base, size_t nelem, size_t width, int (*pfCompare)(const void *, const void *));`

+ 参数说明： 
  + `base`：数组的起始地址。 
  + `nelem`：数组元素个数。 
  + `width`：每个元素的大小（字节数），用于计算元素地址。 
  + `pfCompare`：比较函数指针，定义排序规则。
 
+ 比较函数规则： 
  + 返回负整数：`*elem1` 应排在 `*elem2` 前面。 
  + 返回 0：`*elem1` 和 `*elem2` 顺序无所谓。 
  + 返回正整数：`*elem1` 应排在 `*elem2` 后面。

+ 示例：按个位数升序排序的比较函数
```c++
#include <stdio.h>
#include <stdlib.h>

// 定义比较函数 MyCompare，按个位数升序排序
int MyCompare(const void *elem1, const void *elem2) {
    // 将 void* 转换为 unsigned int* 类型
    unsigned int *p1 = (unsigned int *)elem1;
    unsigned int *p2 = (unsigned int *)elem2;
    
    // 返回个位数之差，决定排序顺序
    return (*p1 % 10) - (*p2 % 10);
}

int main() {
    // 定义并初始化一个无符号整数数组
    unsigned int an[] = {8, 123, 11, 15, 4};
    
    // 计算数组元素个数
    int num = sizeof(an) / sizeof(an[0]);
    
    // 打印排序前的数组
    printf("Before sorting:\n");
    for (int i = 0; i < num; i++) {
        printf("an[%d] = %u\n", i, an[i]);
    }
    
    // 调用 qsort 排序，按个位数升序
    qsort(an, num, sizeof(unsigned int), MyCompare);
    
    // 打印排序后的数组
    printf("\nAfter sorting (by last digit):\n");
    for (int i = 0; i < num; i++) {
        printf("an[%d] = %u\n", i, an[i]);
    }
    
    return 0;
}

// Before sorting:
// an[0] = 8
// an[1] = 123
// an[2] = 11
// an[3] = 15
// an[4] = 4
// 
// After sorting (by last digit):
// an[0] = 11    // 个位数: 1
// an[1] = 123   // 个位数: 3
// an[2] = 4     // 个位数: 4
// an[3] = 15    // 个位数: 5
// an[4] = 8     // 个位数: 8
```



































